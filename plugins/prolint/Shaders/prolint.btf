<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="prolint">
  
  <include file="common"/>
  <include file="core_utils"/>

  <snippet name="commondefines" type="string">
    <!-- 
#define OGL_DEPTH_SES
#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING

//#define DEBUG

#ifndef FLACH
#define FLACH
#endif
-->
  </snippet>

  



  
  <namespace name="ses">
    <snippet name="rootsolver" type="string">
      <!--
// global constants
float doubtol = 0.00000001;      // min
float doubmin = 0.0;             // zero
float doubmax = 1000000000.0;    // max (inf)

// function prototypes
float acos3( float x);
float cubic( float p, float q, float r);
float curoot( float x);
void computeConstants();
int ferrari( float a, float b, float c, float d, out vec4 rts);
int neumark( float a, float b, float c, float d, out vec4 rts);
int quadratic( float b, float c, out vec4 rts, float dis);


/**
*    Solve quartic equation using either quadratic, Ferrari's or Neumark's algorithm.
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        quadratic, ferrari, neumark.
*/
int quartic( float a, float b, float c, float d, out vec4 rts)
{
    int j, k, nq, nr;
    float odd, even;
    vec4 roots;

    if( a < 0.0 )
        odd = -a;
    else
        odd = a;
    if( c < 0.0 )
        odd -= c;
    else
        odd += c;
    if( b < 0.0 )
        even = -b;
    else
        even = b;
    if( d < 0.0 )
        even -= d;
    else
        even += d;
    
    if( odd < even*doubtol )
    {
        nq = quadratic( b, d, roots, b*b-4.0*d);
        j = 0;
        if( nq == 1 )
        {
            if( roots.x > 0.0 )
            {
                rts.x = sqrt( roots.x);
                rts.y = -rts.x;
                ++j; ++j;
            }
        }
        else if( nq == 2 )
        {
            if( roots.x > 0.0 )
            {
                rts.x = sqrt( roots.x);
                rts.y = -rts.x;
                ++j; ++j;
            }
            if( roots.y > 0.0 )
            {
                rts.z = sqrt( roots.y);
                rts.w = -rts.z;
                ++j; ++j;
            }
        }
        nr = j;
    }
    else
    {
        if( a < 0.0 )
            k = 1;
        else
            k = 0;
        if( b < 0.0 )
            k += k+1;
        else
            k +=k; 
        if( c < 0.0 )
            k += k+1;
        else
            k +=k; 
        if( d < 0.0 )
            k += k+1;
        else
            k +=k; 
        
        if( k == 0 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 1 ) nr = neumark( a, b, c, d, rts);
        else if( k == 2 ) nr = neumark( a, b, c, d, rts);
        else if( k == 3 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 4 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 5 ) nr = neumark( a, b, c, d, rts);
        else if( k == 6 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 7 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 8 ) nr = neumark( a, b, c, d, rts);
        else if( k == 9 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 10 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 11 ) nr = neumark( a, b, c, d, rts);
        else if( k == 12 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 13 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 14 ) nr = ferrari( a, b, c, d, rts);
        else if( k == 15 ) nr = ferrari( a, b, c, d, rts);
    }
    return nr;
} // ===== quartic =====

/**
*    compute constant values
*/
void computeConstants()
{
    int j;
    doubtol = 1.0;
    for( j = 1; 1.0+doubtol > 1.0; ++j )
    {
        doubtol *= 0.5;
    }
    doubtol = sqrt( doubtol);
    
    doubmin = 0.5;
    for( j = 1; j <= 100; ++j )
    {
        doubmin = doubmin*doubmin;
        if( (doubmin*doubmin) <= (doubmin*doubmin*0.5) )
            break;
    }
    doubmax = 0.7/sqrt( doubmin);
} // ===== setconstants =====

/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int ferrari( float a, float b, float c, float d, out vec4 rts)
{
    rts = vec4( 0.0, 0.0, 0.0, 0.0);
    
    int nquar, n1, n2;
    float asq, ainv2;
    vec4 v1, v2;
    float p, q, r;
    float y;
    float e, f, esq, fsq, ef;
    float g, gg, h, hh;

    asq = a*a;

    p = b;
    q = a * c - 4.0 * d;
    r = ( asq - 4.0 * b) * d + c*c;
    y = cubic( p, q, r);

    esq = 0.25 * asq - b - y;
    if( esq < 0.0 )
        return(0);
    else
    {
        fsq = 0.25*y*y - d;
        if( fsq < 0.0 )
            return 0;
        else
        {
            ef = -(0.25*a*y + 0.5*c);
            if( ((a > 0.0) && (y > 0.0) && (c > 0.0))
                || ((a > 0.0) && (y < 0.0) && (c < 0.0))
                || ((a < 0.0) && (y > 0.0) && (c < 0.0))
                || ((a < 0.0) && (y < 0.0) && (c > 0.0))
                ||  (a == 0.0) || (y == 0.0) || (c == 0.0) )
            // use ef
            {
                if( (b < 0.0) && (y < 0.0) && (esq > 0.0) )
                {
                    e = sqrt( esq);
                    f = ef/e;
                }
                else if( (d < 0.0) && (fsq > 0.0) )
                {
                    f = sqrt( fsq);
                    e = ef/f;
                }
                else
                {
                    e = sqrt( esq);
                    f = sqrt( fsq);
                    if( ef < 0.0 ) f = -f;
                }
            }
            else
            {
                e = sqrt( esq);
                f = sqrt( fsq);
                if( ef < 0.0 ) f = -f;
            }
            // note that e >= 0.0
            ainv2 = a*0.5;
            g = ainv2 - e;
            gg = ainv2 + e;
            if( ((b > 0.0) && (y > 0.0))
                || ((b < 0.0) && (y < 0.0)) )
            {
                if( ( a > 0.0) && (e != 0.0) )
                    g = (b + y)/gg;
                else if( e != 0.0 )
                    gg = (b + y)/g;
            }
            if( (y == 0.0) && (f == 0.0) )
            {
                h = 0.0;
                hh = 0.0;
            }
            else if( ((f > 0.0) && (y < 0.0))
                || ((f < 0.0) && (y > 0.0)) )
            {
                hh = -0.5*y + f;
                h = d/hh;
            }
            else
            {
                h = -0.5*y - f;
                hh = d/h;
            }
            n1 = quadratic( gg, hh, v1, gg*gg - 4.0 * hh);
            n2 = quadratic( g, h, v2, g*g - 4.0 * h);
            nquar = n1 + n2;
            rts.x = v1.x;
            rts.y = v1.y;
            if( n1 == 0 )
            {
                rts.x = v2.x;
                rts.y = v2.y;
            }
            else
            {
                rts.z = v2.x;
                rts.w = v2.y;
            }
            return nquar;
        }
    }
} // ===== ferrari =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, e - coefficients of equation.
*
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*     calls:
*        cubic
*        quadratic
*/
int neumark( float a, float b, float c, float d, out vec4 rts)
{
    int nquar, n1, n2;
    float y, g, gg, h, hh, gdis, gdisrt, hdis, hdisrt, g1, g2, h1, h2;
    float bmy, gerr, herr, y4, d4, bmysq;
    vec4 v1, v2;
    float asq;
    float p,q,r;
    float hmax,gmax;

    asq = a*a ;

    p = -b*2.0;
    q = b*b + a*c - 4.0*d;
    r = (c - a*b)*c + asq*d;
    y = cubic( p, q, r);

    bmy = b - y;
    y4 = y*4.0;
    d4 = d*4.0;
    bmysq = bmy*bmy ;
    gdis = asq - y4 ;
    hdis = bmysq - d4 ;
    if( (gdis < 0.0) || (hdis < 0.0) )
        return 0;
    else
    {
        g1 = a*0.5;
        h1 = bmy*0.5;
        gerr = asq + y4;
        herr = hdis;
        if( d > 0.0 )
            herr = bmysq + d4;
        if( (y < 0.0) || (herr*gdis > gerr*hdis) )
        {
            gdisrt = sqrt(gdis);
            g2 = gdisrt*0.5;
            if( gdisrt != 0.0 )
                h2 = (a*h1 - c)/gdisrt;
            else
                h2 = 0.0;
        }
        else
        {
            hdisrt = sqrt(hdis);
            h2 = hdisrt*0.5;
            if( hdisrt != 0.0 )
                g2 = (a*h1 - c)/hdisrt;
            else
                g2 = 0.0;
        } 
        //note that in the following, the tests ensure non-zero denominators
        h = h1 - h2 ;
        hh = h1 + h2 ;
        hmax = hh ;
        if( hmax < 0.0 ) hmax = -hmax;
        if( hmax < h ) hmax = h;
        if( hmax < -h ) hmax = -h;
        if( (h1 > 0.0 ) && (h2 > 0.0)) h = d/hh;
        if( (h1 < 0.0 ) && (h2 < 0.0)) h = d/hh;
        if( (h1 > 0.0 ) && (h2 < 0.0)) hh = d/h;
        if( (h1 < 0.0 ) && (h2 > 0.0)) hh = d/h;
        if( h > hmax ) h = hmax;
        if( h < -hmax ) h = -hmax;
        if( hh > hmax ) hh = hmax;
        if( hh < -hmax ) hh = -hmax;

        g = g1 - g2;
        gg = g1 + g2;
        gmax = gg;
        if( gmax < 0.0 ) gmax = -gmax;
        if( gmax < g ) gmax = g;
        if( gmax <  -g ) gmax = -g;
        if( (g1 > 0.0) && (g2 > 0.0) ) g = y/gg;
        if( (g1 < 0.0) && (g2 < 0.0) ) g = y/gg;
        if( (g1 > 0.0) && (g2 < 0.0) ) gg = y/g;
        if( (g1 < 0.0) && (g2 > 0.0) ) gg = y/g;
        if( g > gmax ) g = gmax;
        if( g <  -gmax ) g = -gmax;
        if( gg > gmax ) gg = gmax;
        if( gg <  -gmax ) gg = -gmax;

        n1 = quadratic( gg, hh, v1, gg*gg - 4.0*hh);
        n2 = quadratic( g, h, v2, g*g - 4.0*h);
        nquar = n1+n2;
        rts.x = v1.x;
        rts.x = v1.y;
        if( n1 == 0 )
        {
            rts.x = v2.x;
            rts.y = v2.y;
        }
        else
        {
            rts.z = v2.x;
            rts.w = v2.y;
        }

        return nquar;
    }
} // ===== neumark =====


/**
*    solve the quadratic equation
*        x**2+b*x+c = 0
*
*    input:
*        b, c - coefficients of equation.
*    output:
*        [return nquad] - number of real roots.
*        rts - array of root values.+
*        
*    called by:
*        ferrari
*        neumark
*/
int quadratic( float b, float c, out vec4 rts, float dis)
{
    int nquad;
    float rtdis;

    if( dis >= 0.0 )
    {
        nquad = 2;
        rtdis = sqrt( dis) ;
        if( b > 0.0 )
            rts.x = ( -b - rtdis) * 0.5;
        else
            rts.x = ( -b + rtdis) * 0.5;
        if( rts.x == 0.0 )
            rts.y = -b;
        else
            rts.y = c/rts.x;
    }
    else
    {
        nquad = 0;
        rts.x = 0.0;
        rts.y = 0.0;
    }
    return nquad;
} // ===== quadratic =====


/**
*    find the lowest real root of the cubic equation
*        x**3 + p*x**2 + q*x + r = 0 
*
*    input parameters:
*        p, q, r - coefficients of cubic equation. 
*    output:
*        cubic - a real root.
*
*    calls:
*        acos3
*        curoot
*    called by:
*        ferrari
*        neumark
*/
float cubic( float p, float q, float r)
{    
    int nrts;
    float po3, po3sq, qo3;
    float uo3, u2o3, uo3sq4, uo3cu4;
    float v, vsq, wsq;
    float m, mcube, n;
    float muo3, s, scube, t, cosk, sinsqk;
    float root;

    m = 0.0;
    nrts = 0;
    if( (p > doubmax) || (p <  -doubmax) )
        root = -p;
    else
    {
        if( (q > doubmax) || (q <  -doubmax) )
        {
            if (q > 0.0)
                root = -r/q;
            else
                root = -sqrt( -q);
        }
        else
        {
            if( (r > doubmax) || (r <  -doubmax) )
                root = -curoot( r);
            else
            {
                po3 = p * (1.0/3.0);
                po3sq = po3*po3 ;
                if( po3sq > doubmax )
                    root = -p;
                else
                {
                    v = r + po3*(po3sq + po3sq - q) ;
                    if( (v > doubmax) || (v < -doubmax) )
                        root = -p;
                    else
                    {
                        vsq = v*v ;
                        qo3 = q * (1.0/3.0);
                        uo3 = qo3 - po3sq ;
                        u2o3 = uo3 + uo3 ;
                        if( (u2o3 > doubmax) || (u2o3 < -doubmax) )
                        {
                            if (p == 0.0)
                            {
                                if (q > 0.0)
                                    root = -r/q;
                                else
                                    root = -sqrt( -q);
                            }
                            else
                                root = -q/p;
                        }
                        uo3sq4 = u2o3 * u2o3 ;
                        if( uo3sq4 > doubmax)
                        {
                            if (p == 0.0)
                            {
                                if( q > 0.0 )
                                    root = -r/q;
                                else
                                    root = -sqrt( abs( q));
                            }
                            else
                                root = -q/p;
                        }
                        uo3cu4 = uo3sq4 * uo3;
                        wsq = uo3cu4 + vsq;
                        if( wsq >= 0.0 )
                        {
                            // cubic has one real root
                            nrts = 1;
                            if( v <= 0.0 )
                                mcube = ( -v + sqrt( wsq))*0.5;
                            if( v  > 0.0 )
                                mcube = ( -v - sqrt( wsq))*0.5;
                            m = curoot( mcube);
                            if( m != 0.0 )
                                n = -uo3/m;
                            else
                                n = 0.0;
                            root = m + n - po3;
                        }
                        else
                        {
                            nrts = 3;
                            // cubic has three real roots
                            if( uo3 < 0.0 )
                            {
                                muo3 = -uo3;
                                s = sqrt( muo3);
                                scube = s*muo3;
                                t =  -v/(scube+scube);
                                cosk = acos3( t);
                                if( po3 < 0.0 )
                                    root = (s+s)*cosk - po3;
                                else
                                {
                                    sinsqk = 1.0 - cosk*cosk;
                                    if( sinsqk < 0.0 )
                                        sinsqk = 0.0;
                                    root = s*( -cosk - sqrt( 3.0)*sqrt( sinsqk)) - po3;
                                }
                            }
                            else
                                // cubic has multiple root
                                root = curoot( v) - po3;
                        }
                    }
                }
            }
        }
    }
    return root;
} // ===== cubic =====


/** 
*    find cube root of x.
*
*    called by:
*        cubic 
*/
float curoot( float x)
{
    float value;
    float absx;
    int neg;

    neg = 0;
    absx = x;
    if( x < 0.0 )
    {
        absx = -x;
        neg = 1;
    }
    value = exp( log( absx)*(1.0/3.0));
    if( neg == 1 )
        value = -value;
    return value;
} // ===== curoot =====


/** 
* find cos(acos(x)/3) 
*
* called by:
*    cubic 
*/
float acos3( float x)
{
    return cos( acos( x)*(1.0/3.0));
} // ===== acos3 =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int simpleFerrari( float a, float b, float c, float d, out vec4 rts)
{
    int nquar, n1, n2;
    float asq, y;
    vec4 v1, v2;
    float p, q, r;
    float e, f, esq, fsq;
    float g, gg, h, hh;

    asq = a*a;

    p = -b;
    q = a*c-4.0*d;
    r = -asq*d - c*c + 4.0*b*d;
    y = cubic( p, q, r);

    esq = 0.25*asq - b + y;
    fsq = 0.25*y*y - d;
    if( esq < 0.0 )
        return 0;
    else
    {
        if( fsq < 0.0 )
            return 0;
        else
        {
            e = sqrt( esq);
            f = sqrt( fsq);
            g = 0.5*a - e;
            h = 0.5*y - f;
            gg = 0.5*a + e;
            hh = 0.5*y + f;
            n1 = quadratic( gg, hh, v1, gg*gg - 4.0*hh) ;
            n2 = quadratic( g, h, v2, g*g - 4.0*h) ;
            nquar = n1 + n2;
            rts.x = v1.x;
            rts.y = v1.y;
            if( n1 == 0 )
            {
                rts.x = v2.x;
                rts.y = v2.y;
            }
            else
            {
                rts.z = v2.x;
                rts.w = v2.y;
            }
            return nquar;
        }
    }
} // ===== simple =====


/**
*    solve the quartic equation
*        x**4 + a*x**3 + b*x**2 + c*x + d = 0
*
*    input:
*        a, b, c, d - coefficients of equation.
*    output:
*        [return nquar] - number of real roots.
*        rts - array of root values.
*
*    calls:
*        cubic
*        quadratic
*/
int descartes( float a, float b, float c, float d, out vec4 rts)
{
    int nrts;
    int r1,r2;
    vec4 v1, v2;
    float y;
    float p,q,r;
    float A,B,C;
    float m,n1,n2;
    float d3o8,d3o256;
    float inv8,inv16;
    float asq;
    float Binvm;

    d3o8 = 3.0/8.0;
    inv8 = 1.0/8.0;
    inv16 = 1.0/16.0;
    d3o256 = 3.0/256.0;

    asq = a*a;

    A = b - asq*d3o8;
    B = c + a*(asq*inv8 - b*0.5);
    C = d + asq*(b*inv16 - asq*d3o256) - a*c*0.25;

    p = 2.0*A;
    q = A*A - 4.0*C;
    r = -B*B;

    y = cubic( p, q, r) ;
    if( y <= 0.0 ) 
        nrts = 0;
    else
    {
        m = sqrt( y);
        Binvm = B/m;
        n1 = ( y + A + Binvm)*0.5;
        n2 = ( y + A - Binvm)*0.5;
        r1 = quadratic(-m, n1, v1, y-4.0*n1);
        r2 = quadratic( m, n2, v2, y-4.0*n2);
        rts.x = v1.x-a*0.25;
        rts.y = v1.y-a*0.25;
        if( r1 == 0 )
        {
            rts.x = v2.x-a*0.25;
            rts.y = v2.y-a*0.25;
        }
        else
        {
            rts.z = v2.x-a*0.25;
            rts.w = v2.y-a*0.25;
        }
        nrts = r1+r2;
    } 
    return nrts;
} // ===== descartes =====
-->
    </snippet>

    <snippet name="decodecolor" type="string">
      <!--

vec3 decodeColor( float codedColor)
{
    float col = codedColor;
    float red, green;
    if( col >= 1000000.0 )
        red = floor( col / 1000000.0);
    else
        red = 0.0;
    col = col - ( red * 1000000.0);
    if( col >= 1000.0)
        green = floor( col / 1000.0);
    else
        green = 0.0;
    col = col - ( green * 1000.0);
    if( col > 256.0 )
        col = 0.0;
    return vec3( red / 255.0, green / 255.0, col / 255.0 );
}

-->
    </snippet>

    <snippet name="dot1" type="string">
      <!--

float dot1( vec3 v1)
{
    return dot( v1, v1);
}

-->
    </snippet>

    <shader name="sphereVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;

uniform mat4 MVP;           
uniform mat4 MVinv;          
uniform mat4 MVPinv;         
uniform mat4 MVPtransp;      

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;


layout(shared, binding = 3) buffer atomPos_data {
    vec4 atomPos[];
};


layout(shared, binding = 4) buffer atomColorTable_data {
    vec4 atomColorTable[];
};


layout(shared, binding = 8) buffer atomPosIdx_data {
    int atomPosIdx[];
};

void main(void) {
	
    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = atomPos[gl_VertexID];
    //vec4 inPos = atomPos[atomPosIdx[gl_VertexID]];
    
	rad = inPos.w;
    squarRad = rad * rad;
    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = MVinv[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = MVinv * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = MVinv * normalize( gl_LightSource[0].position);

    // send color to fragment shader
    gl_FrontColor = atomColorTable[gl_VertexID];
	//gl_FrontColor = atomColorTable[atomPosIdx[gl_VertexID]];

    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = MVinv[3] + MVinv[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = MVinv[3] + MVinv[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;

#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING

}
-->
      </snippet>
    </shader>
    
<shader name="sphereFragment">
    <snippet type="version">120</snippet>
    <snippet name="commondefines"/>
    <snippet name="::common::lighting::simple"/>
    <snippet type="string">
    <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

uniform mat4 MVPinv;
uniform mat4 MVPtransp;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying float squarRad;
varying float rad;


void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);


    // transform fragment coordinates from view coordinates to object coordinates.
    coord = MVPinv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space


    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);


    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }

    float lambdaSign = -1.0;
  
    lambda = d1 + (lambdaSign * sqrt(radicand));                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // "calc" normal at intersection point
    vec3 normal = sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // chose color for lighting
    vec3 color = gl_Color.rgb;
#ifdef DEBUG
	color = vec3(1.0, 0.5, 0.0);
#endif

    // phong lighting with directional light
    gl_FragColor = vec4(LocalLighting(ray, normal, lightPos.xyz, color), 1.0);

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(MVPtransp[2], Ding);
    float depthW = dot(MVPtransp[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;

}
-->
      </snippet>
    </shader>

    <shader name="sphericaltriangleVertex">
      <snippet type="version">130</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

    uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
    uniform vec3 zValues;
    uniform vec3 fogCol;
    uniform vec2 texOffset;
    uniform mat4 MVP;
    uniform mat4 MVinv;
    
    #ifndef CALC_CAM_SYS
    uniform vec3 camIn;
    uniform vec3 camUp;
    uniform vec3 camRight;
    #endif // CALC_CAM_SYS
    
    varying vec4 objPos;
    varying vec4 camPos;
    varying vec4 lightPos;
    
    varying vec4 inVec1;
    varying vec4 inVec2;
    varying vec4 inVec3;
    varying vec3 inColor0;
    varying vec3 inColor1;
    varying vec3 inColor2;
	
	flat out int probeIdx;
	
	
	layout(shared, binding = 5) buffer intersections_data {
		vec4 intersections[];
	};
	
	layout(shared, binding = 3) buffer atomPos_data {
		vec4 atomPos[];
	};
	
	layout(shared, binding = 4) buffer atomColorTable_data {
		vec4 atomColorTable[];
	};
	
	layout(shared, binding = 6) buffer spheresComb3_data {
		ivec4 SphereComb3[];
	};


    
    void main(void) {
		probeIdx = gl_VertexID;		
		inVec1 = atomPos[SphereComb3[gl_VertexID].x];
		inVec2 = atomPos[SphereComb3[gl_VertexID].y];
		inVec3 = atomPos[SphereComb3[gl_VertexID].z];
		inVec1.xyz -= intersections[gl_VertexID].xyz;
		inVec2.xyz -= intersections[gl_VertexID].xyz;
		inVec3.xyz -= intersections[gl_VertexID].xyz;
		inColor0 = atomColorTable[SphereComb3[gl_VertexID].x].rgb;
		inColor1 = atomColorTable[SphereComb3[gl_VertexID].y].rgb;
		inColor2 = atomColorTable[SphereComb3[gl_VertexID].z].rgb;
		
		// remove the sphere radius from the w coordinates to the rad varyings
		vec4 inPos = intersections[gl_VertexID];
		inVec1.w = inPos.w;
		inVec2.w = inPos.w * inPos.w;
		inPos.w = 1.0;
		
		// DEBUG
		//texCoord2.xy = vec2( attribVec1.w, attribVec2.w);
		
		// object pivot point in object space    
		objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)
		
		// calculate cam position
		camPos = MVinv[3]; // (C) by Christoph
		camPos.xyz -= objPos.xyz; // cam pos to glyph space
		
		// calculate light position in glyph space
		// USE THIS LINE TO GET POSITIONAL LIGHTING
		//lightPos = MVinv * gl_LightSource[0].position - objPos;
		// USE THIS LINE TO GET DIRECTIONAL LIGHTING
		lightPos = MVinv * normalize( gl_LightSource[0].position);
		
		// Sphere-Touch-Plane-Approach
		vec2 winHalf = 2.0 / viewAttr.zw; // window size
		
		vec2 d, p, q, h, dd;
		
		// get camera orthonormal coordinate system
		vec4 tmp;
		
		#ifdef CALC_CAM_SYS
		// camera coordinate system in object space
		tmp = MVinv[3] + MVinv[2];
		vec3 camIn = normalize(tmp.xyz);
		tmp = MVinv[3] + MVinv[1];
		vec3 camUp = tmp.xyz;
		vec3 camRight = normalize(cross(camIn, camUp));
		camUp = cross(camIn, camRight);
		#endif // CALC_CAM_SYS
		
		vec2 mins, maxs;
		vec3 testPos;
		vec4 projPos;
		
		// projected camera vector
		vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));
		
		vec3 cpj1 = camIn * c2.z + camRight * c2.x;
		vec3 cpm1 = camIn * c2.x - camRight * c2.z;
		
		vec3 cpj2 = camIn * c2.z + camUp * c2.y;
		vec3 cpm2 = camIn * c2.y - camUp * c2.z;
		
		d.x = length(cpj1);
		d.y = length(cpj2);
		
		dd = vec2(1.0) / d;
		
		p = inVec2.w * dd;
		q = d - p;
		h = sqrt(p * q);
		//h = vec2(0.0);
		
		p *= dd;
		h *= dd;
		
		cpj1 *= p.x;
		cpm1 *= h.x;
		cpj2 *= p.y;
		cpm2 *= h.y;
		
		// TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
		testPos = objPos.xyz + cpj1 + cpm1;
		projPos = MVP * vec4(testPos, 1.0);
		projPos /= projPos.w;
		mins = projPos.xy;
		maxs = projPos.xy;
		
		testPos -= 2.0 * cpm1;
		projPos = MVP * vec4(testPos, 1.0);
		projPos /= projPos.w;
		mins = min(mins, projPos.xy);
		maxs = max(maxs, projPos.xy);
		
		testPos = objPos.xyz + cpj2 + cpm2;
		projPos = MVP * vec4(testPos, 1.0);
		projPos /= projPos.w;
		mins = min(mins, projPos.xy);
		maxs = max(maxs, projPos.xy);
		
		testPos -= 2.0 * cpm2;
		projPos = MVP * vec4(testPos, 1.0);
		projPos /= projPos.w;
		mins = min(mins, projPos.xy);
		maxs = max(maxs, projPos.xy);
		
		gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
		gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
		
		#ifdef SMALL_SPRITE_LIGHTING
		// for normal crowbaring on very small sprites
		lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
		#endif // SMALL_SPRITE_LIGHTING
		
    }
-->
      </snippet>
    </shader>

    <shader name="sphericaltriangleFragment">
      <snippet type="version">130</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform vec2 texOffset;
// texture sampler
uniform sampler2D tex;
uniform float alpha = 0.5;

uniform mat4 MVP;
uniform mat4 MVinv;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;
    
varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;

varying vec4 inVec1;
varying vec4 inVec2;
varying vec4 inVec3;
varying vec3 inColor0;
varying vec3 inColor1;
varying vec3 inColor2;

flat in int probeIdx;

layout(shared, binding = 2) buffer shader_data {
    vec4 probePosList[];
};





-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet name="dot1"/>
      <snippet type="string">
        <!--

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    float rad = inVec1.w;
    float squarRad = inVec2.w;
	
	// transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = MVPinv * coord;
    coord /= coord.w;
	coord -= objPos; // ... and to glyph space
    //coord -= vec4( probePosList[50 * probeIdx], 1.0); //objPos; // ... and to glyph space

    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squarRad - d2s;                        // square of difference of projected length and lambda
    
    if (radicand < 0.0) { discard; }
    
    lambda = d1 + sqrt(radicand);                           // lambda
    vec3 sphereintersection = lambda * ray + camPos.xyz;    // intersection point

    // calculate depth
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    //vec4 Ding = vec4(sphereintersection + probePosList[50 * probeIdx], 1.0);
    float depth = dot(MVPtransp[2], Ding);
    float depthW = dot(MVPtransp[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#else 
    gl_FragDepth = gl_FragCoord.z;
#endif // DEPTH

    // compute the actual position of the intersection with the sphere
    vec3 pos1 = sphereintersection + objPos.xyz;
    // cut with plane 1
    vec3 planeNormal = normalize( cross( inVec1.xyz, inVec2.xyz));
    float d = dot( objPos.xyz, planeNormal);
    float dist1 = dot( pos1, planeNormal) - d;
    float dist2 = dot( inVec3.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { 
		discard; 
		//gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); return;
	}
    // cut with plane 2
    planeNormal = normalize( cross( inVec2.xyz, inVec3.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec1.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { 
		discard; 
		//gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); return;
	}
    // cut with plane 3
    planeNormal = normalize( cross( inVec1.xyz, inVec3.xyz));
    d = dot( objPos.xyz, planeNormal);
    dist1 = dot( pos1, planeNormal) - d;
    dist2 = dot( inVec2.xyz + objPos.xyz, planeNormal) - d;
    if( ( dist2 < 0.0 && dist1 > 0.0 ) || ( dist2 > 0.0 && dist1 < 0.0 ) ) { 
		discard; 
		// gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); return;
	}
    // discard the point if it is eaten away by one of the neighbouring probes
    // ==> check first, if one of the probes is nearly dual to the object position
    /*
    if( ( dot1( inProbe1.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe1.xyz) < squarRad ) ) || 
        ( dot1( inProbe2.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe2.xyz) < squarRad ) ) || 
            ( dot1( inProbe3.xyz - objPos.xyz) > 0.1 && ( dot1( pos1 - inProbe3.xyz) < squarRad ) ) ||
            ( dot1( pos1 - dualProbe) < inVec3.w ) ) { discard; }
    */
	
    vec3 probePos;
    int i = 0;
	probePos = probePosList[50 * probeIdx + i].xyz;
	while( length(probePos) > 0.0001 && i < 50) {
		if( dot1( pos1 - probePos) < squarRad ) { discard; }
		i++;
		probePos = probePosList[50 * probeIdx + i].xyz;
	}
	
    // "calc" normal at intersection point
    vec3 normal = -sphereintersection / rad;
#ifdef SMALL_SPRITE_LIGHTING
    normal = mix(-ray, normal, lightPos.w);
#endif // SMALL_SPRITE_LIGHTING

    // ========== START compute color ==========
    // compute auxiliary direction vectors
    vec3 u = inVec1.xyz - inVec2.xyz;
    vec3 v = inVec3.xyz - inVec2.xyz;
    // base point and direction of ray from the origin to the intersection point
    vec3 w = -inVec2.xyz;
    vec3 dRay = normalize( sphereintersection);
    // cross products for computing the determinant
    vec3 wXu = cross( w, u);
    vec3 dXv = cross( dRay, v);
    // compute interse determinant
    float invdet = 1.0 / dot( dXv, u);
    // compute weights
    float beta = dot( dXv, w) * invdet;
    float gamma = dot( wXu, dRay) * invdet;
    float alpha2 = 1.0 - ( beta + gamma);
    // compute color
    vec3 color = inColor1 * alpha2 + inColor0 * beta + inColor2 * gamma;
#ifdef FLATSHADE_SES
    if( alpha2 > beta && alpha2 > gamma )
        color = decodeColor( inColor1);
    else if( beta > alpha2 && beta > gamma )
        color = decodeColor( inColor0);
    else
        color = decodeColor( inColor2);
#endif // FLATSHADE_SES

    // phong lighting with directional light
    gl_FragColor = vec4( LocalLighting(ray, normal, lightPos.xyz, color), 1.0);
    
#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;

}
-->
      </snippet>
    </shader>

    <shader name="torusVertex">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet type="string">
        <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec3 zValues;
uniform vec3 fogCol;
uniform mat4 MVP;
uniform mat4 MVinv;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

uniform float probeRad;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying vec4 color0;
varying vec4 color1;
varying vec2 colParams;


// defines for Buliding Area
vec4 quatC;

vec3 zAxis;
vec3 torusAxis;
vec3 rotAxis;
vec3 P;
vec3 X1;
vec3 X2;
vec3 C;
vec3 planeNormal;

vec3 cutPlaneNorm;


vec3 ai;
vec3 aj;

float dij;
float ri;
float rj;
float rp;
float rij;
float halfAngle;
float len;
float distance;
float d;

vec3 tij;


layout(shared, binding = 3) buffer atomPos_data {
		vec4 atomPos[];
	};
	
	layout(shared, binding = 4) buffer atomColorTable_data {
		vec4 atomColorTable[];
	};
	
	layout(shared, binding = 7) buffer torusAxes_data {
		ivec2 torusAxes[];
	};


void main(void) {
	
	
	// Building Area
	zAxis = vec3(0.0f, 0.0f, 1.0f);
	ai = atomPos[torusAxes[gl_VertexID].x].xyz;
    aj = atomPos[torusAxes[gl_VertexID].y].xyz;
	
	dij = length(aj - ai);
    ri = atomPos[torusAxes[gl_VertexID].x].w;
    rj = atomPos[torusAxes[gl_VertexID].y].w;
    rp = probeRad;
    rij = 0.5f * pow(pow(ri + rj + 2.0f * rp, 2.0f) - pow(dij, 2.0f), 0.5f) * (pow(pow(dij, 2.0f) - pow(ri - rj, 2.0f), 0.5f) / dij);
	tij = 0.5f * (ai + aj) + 0.5f * (aj - ai) * ((ri + rp) * (ri + rp) - (rj + rp) * (rj + rp)) / (dij * dij);
	torusAxis = ai - tij;
    torusAxis = normalize(torusAxis);
	rotAxis = cross(torusAxis, zAxis);
    rotAxis = normalize(rotAxis);
	
	// do quatC calculations
	zAxis = normalize(zAxis);
	halfAngle = acos(dot(torusAxis,zAxis));
    halfAngle = 0.5 * halfAngle;

	if( length(zAxis) > 0.0001 ) {
		len = sin(halfAngle);
		quatC.x = rotAxis.x * len;
		quatC.y = rotAxis.y * len;
		quatC.z = rotAxis.z * len;
		quatC.w = cos(halfAngle);
	} else {
		quatC.x = 0.0;
		quatC.y = 0.0;
		quatC.z = 0.0;
		quatC.w = 1.0;
	}
	///////////////////////////////
	
	P = tij + rotAxis * rij;

    X1 = P - ai;
    X1 = normalize(X1);
    X1 *= ri;
    X2 = P - aj;
    X2 = normalize(X2); 
    X2 *= rj;
    d = dot(X1 + ai - tij, torusAxis);

    C = ai - aj;
    C = (length(P - aj) / (length(P - ai) + length(P - aj))) * C;
    distance = length(X2 - C); 
    C = (C + aj) - tij;
	
	
	// Building Area end
	
	
    const vec4 quatConst = vec4(1.0, -1.0, 0.5, 0.0);
    vec4 tmp, tmp1;

    // remove the sphere radius from the w coordinates to the rad varyings
    vec4 inPos = vec4(tij.x, tij.y, tij.z, 1.0f);
	//inPos = gl_Vertex;

    radii.x = rp;
    radii.y = radii.x * radii.x;
    radii.z = rij;
    radii.w =  radii.z * radii.z;
    
     color0 = atomColorTable[torusAxes[gl_VertexID].x];
	 color1 = atomColorTable[torusAxes[gl_VertexID].y];
	 colParams = vec2( d, dot(X2 + aj - tij, torusAxis) - d);
					
    
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // orientation quaternion to inverse rotation matrix conversion
    // Begin: Holy code!
    tmp = quatC.xzyw * quatC.yxzw;                        // tmp <- (xy, xz, yz, ww)
    tmp1 = quatC * quatC.w;                                    // tmp1 <- (xw, yw, zw, %)
    tmp1.w = -quatConst.z;                                // tmp1 <- (xw, yw, zw, -0.5)

    rotMatT0.xyz = tmp1.wzy * quatConst.xxy + tmp.wxy;    // matrix0 <- (ww-0.5, xy+zw, xz-yw, %)
    rotMatT0.x = quatC.x * quatC.x + rotMatT0.x;                // matrix0 <- (ww+x*x-0.5, xy+zw, xz-yw, %)
    rotMatT0 = rotMatT0 + rotMatT0;                     // matrix0 <- (2(ww+x*x)-1, 2(xy+zw), 2(xz-yw), %)

    rotMatT1.xyz = tmp1.zwx * quatConst.yxx + tmp.xwz;     // matrix1 <- (xy-zw, ww-0.5, yz+xw, %)
    rotMatT1.y = quatC.y * quatC.y + rotMatT1.y;             // matrix1 <- (xy-zw, ww+y*y-0.5, yz+xw, %)
    rotMatT1 = rotMatT1 + rotMatT1;                     // matrix1 <- (2(xy-zw), 2(ww+y*y)-1, 2(yz+xw), %)

    rotMatT2.xyz = tmp1.yxw * quatConst.xyx + tmp.yzw;     // matrix2 <- (xz+yw, yz-xw, ww-0.5, %)
    rotMatT2.z = quatC.z * quatC.z + rotMatT2.z;             // matrix2 <- (xz+yw, yz-xw, ww+zz-0.5, %)
    rotMatT2 = rotMatT2 + rotMatT2;                     // matrix2 <- (2(xz+yw), 2(yz-xw), 2(ww+zz)-1, %)    
    // End: Holy code!

    // rotate and copy the visibility sphere
    visibilitySphere.xyz = rotMatT0 * C.x + rotMatT1 * C.y + rotMatT2 * C.z;
    visibilitySphere.w =distance;
    
    // calculate cam position
    tmp = MVinv[3]; // (C) by Christoph
    tmp.xyz -= objPos.xyz; // cam move
    camPos.xyz = rotMatT0 * tmp.x + rotMatT1 * tmp.y + rotMatT2 * tmp.z;

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = MVinv * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    lightPos = MVinv * normalize( gl_LightSource[0].position);
    lightPos.xyz = rotMatT0 * lightPos.x + rotMatT1 * lightPos.y + rotMatT2 * lightPos.z;
    
    // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = MVinv[3] + MVinv[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = MVinv[3] + MVinv[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(tmp.xyz, camRight), dot(tmp.xyz, camUp), dot(tmp.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;

    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    ////p = (radii.x + radii.z)*(radii.x + radii.z) * dd;
    p = distance*distance * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);

    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    ////testPos = objPos.xyz + cpj1 + cpm1;
    testPos = C.xyz + objPos.xyz + cpj1 + cpm1;    
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    ////testPos = objPos.xyz + cpj2 + cpm2;
    testPos = C.xyz + objPos.xyz + cpj2 + cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = MVP * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    // set position and point size
    gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_PointSize = max((maxs.x - mins.x) * winHalf.x, (maxs.y - mins.y) * winHalf.y) * 0.5;
    
#ifdef SMALL_SPRITE_LIGHTING
    // for normal crowbaring on very small sprites
    lightPos.w = (clamp(gl_PointSize, 1.0, 5.0) - 1.0) / 4.0;
#endif // SMALL_SPRITE_LIGHTING

}
-->
      </snippet>
    </shader>

    <shader name="torusFragment">
      <snippet type="version">120</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet name="rootsolver"/>
      <snippet type="string">
        <!--
uniform vec4 viewAttr;
uniform vec3 zValues;
uniform vec3 fogCol;
uniform float alpha = 0.5;

uniform mat4 MVPinv;
uniform mat4 MVPtransp;

varying vec4 objPos;
varying vec4 camPos;
varying vec4 lightPos;
varying vec4 radii;
varying vec4 visibilitySphere;

varying vec3 rotMatT0;
varying vec3 rotMatT1; // rotation matrix from the quaternion
varying vec3 rotMatT2;

varying vec4 color0;
varying vec4 color1;
varying vec2 colParams;

-->
      </snippet>
      <snippet name="decodecolor"/>
      <snippet type="string">
        <!--
void main(void) {
    vec4 coord;
    vec3 ray, tmp;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from view coordinates to object coordinates.
    coord = MVPinv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and move

    // calc the viewing ray
    ray = rotMatT0 * coord.x + rotMatT1 * coord.y + rotMatT2 * coord.z;
    ray = normalize( ray - camPos.xyz);

    #define r radii.x
    #define r2 radii.y
    #define R radii.z
    #define R2 radii.w

    // calculate the base point of the ray
    vec3 a = camPos.xyz + ( length( camPos.xyz) - (R + r)) * ray;
    
    // compute coefficients of the quartic equation for the ray-torus-intersection
    float K = dot( a, a) - ( R2 + r2);
    float A = 4.0 * dot( a, ray);
    float B = 2.0 * ( 2.0 * dot( a, ray) * dot( a, ray) + K + 2.0 * R2 * ray.z*ray.z);
    float C = 4.0 * ( K * dot( a, ray) + 2.0 * R2 * a.z * ray.z);
    float D = K*K + 4.0 * R2 * ( a.z*a.z - r2);
    
    vec4 lambdas = vec4( 0.0, 0.0, 0.0, 0.0);
    vec3 intersection;
    // ==> various quartic root solvers (only stabilized ferrari shows good results and performance)
    //int numRoots = quartic( A, B, C, D, lambdas);
    int numRoots = ferrari( A, B, C, D, lambdas);
    //int numRoots = neumark( A, B, C, D, lambdas);
    //int numRoots = simpleFerrari( A, B, C, D, lambdas);
    //int numRoots = descartes( A, B, C, D, lambdas);
    if( numRoots < 2 ) { discard; }
    // get lambda of the first intersection
    /*
    // ==> this test is unnecessary, lambdas.x always holds the value of the second intersection [kroneml 31.8.2008]
    float lambda = lambdas.x;
    if( lambdas.y < lambda && numRoots > 1 && lambdas.y > 0.0 ) { lambda = lambdas.y; }
    if( lambdas.z < lambda && numRoots > 2 && lambdas.z > 0.0 ) { lambda = lambdas.z; }
    if( lambdas.w < lambda && numRoots > 3 && lambdas.w > 0.0 ) { lambda = lambdas.w; }
    // get lambda of the second intersection
    float second;
    if( lambdas.x > lambda ) { second = lambdas.x; } else { second = lambdas.y; }
    if( lambdas.y > lambda && lambdas.y < second && numRoots > 1 ) { second = lambdas.y; }
    if( lambdas.z > lambda && lambdas.z < second && numRoots > 2 ) { second = lambdas.z; }
    if( lambdas.w > lambda && lambdas.w < second && numRoots > 3 ) { second = lambdas.w; }
    */
    float second = lambdas.x;
    intersection = a + ray * second;
    // handle singularity
    bool sing = false;
    if( r > R )
    {
        //float radius2 = r2 - 2.0 * ( r2 -r*R) + r2 - 2.0 * r * R + R2;
        //float cutRad2 = r2 - radius2;
        //float cutRad2 = 2.0 * ( r2 - r * R) - r2 + 2.0 * r * R - R2;
        float cutRad2 = r2 - R2;
        if( dot( intersection, intersection) < cutRad2 )
        {
            second = lambdas.x;
            if( lambdas.y > second && numRoots > 1 ) { second = lambdas.y; }
            if( lambdas.z > second && numRoots > 2 ) { second = lambdas.z; }
            if( lambdas.w > second && numRoots > 3 ) { second = lambdas.w; }
            intersection = a + ray * second;
        }
    }
    // discard fragment if the intersection point lies outside the sphere
    if( length( intersection - visibilitySphere.xyz) > visibilitySphere.w ) { discard; }
    
    // discard fragment if the intersection point lies outside the 'pie slice'

    float d = ( dot( intersection, vec3( 0.0, 0.0, 1.0)) - colParams.x) / colParams.y;
    // chose color for lighting
    vec3 color = mix( color0.xyz, color1.xyz, d);
    
    // compute inward-facing normal
    vec3 normal;
    float factor01 = ( dot( intersection, intersection) - r2 - R2);
    normal.x = 4.0*intersection.x*factor01;
    normal.y = 4.0*intersection.y*factor01;
    normal.z = 4.0*intersection.z*factor01 + 8.0*R2*intersection.z;
    normal = -normalize( normal);
    
#ifdef FLATSHADE_SES
    if( d <= 0.5 )
        color = decodeColor( colors.x);
    else
        color = decodeColor( colors.y);
#endif // FLATSHADE_SES
    // uniform color
    //color = vec3( 1.0, 0.75, 0.0);
    //color = vec3( 0.98, 0.82, 0.0 ); // for VIS
    //color = vec3( 0.02, 0.75, 0.02);
    //color = vec3( 0.19, 0.52, 0.82);

#ifdef DEBUG
	color = vec3(0.0, 0.5, 1.0);
#endif

    // phong lighting with directional light
    gl_FragColor = vec4( LocalLighting( ray, normal, lightPos.xyz, color), 1.0);
    gl_FragDepth = gl_FragCoord.z;
    
    // calculate depth
#ifdef DEPTH
    tmp = intersection;
    intersection.x = dot( rotMatT0, tmp.xyz);
    intersection.y = dot( rotMatT1, tmp.xyz);
    intersection.z = dot( rotMatT2, tmp.xyz);

    intersection += objPos.xyz;

    vec4 Ding = vec4( intersection, 1.0);
    float depth = dot(MVPtransp[2], Ding);
    float depthW = dot(MVPtransp[3], Ding);
#ifdef OGL_DEPTH_SES
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
#else
    //gl_FragDepth = ( depth + zValues.y) / zValues.z;
    gl_FragDepth = (depth + zValues.y)/( zValues.z + zValues.y);
#endif // OGL_DEPTH_SES
#endif // DEPTH

#ifdef FOGGING_SES
    float f = clamp( ( 1.0 - gl_FragDepth)/( 1.0 - zValues.x ), 0.0, 1.0);
    gl_FragColor.rgb = mix( fogCol, gl_FragColor.rgb, f);
#endif // FOGGING_SES
    gl_FragColor.a = alpha;
    
    tmp = normal;
    normal.x = dot( rotMatT0, tmp.xyz);
    normal.y = dot( rotMatT1, tmp.xyz);
    normal.z = dot( rotMatT2, tmp.xyz);
    
}
-->
      </snippet>
    </shader>
</namespace>
	





 
 <namespace name="docking">
      <shader name="sphereVertexGeom">
      <snippet type="version">140</snippet>
      <snippet type="string">
        <!--
uniform mat4 modelview;
uniform mat4 proj;

in vec4 vertex;
in vec4 color;

out vec4 inColor;

void main(void) {
    gl_Position = vertex;
    inColor = color;
}
-->
      </snippet>
    </shader>
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

 <shader name="sphereGeom">
      <snippet type="version">140</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

//layout (points) in;
//layout (triangle_strip, max_vertices = 4) out;

uniform mat4 modelview;
uniform mat4 proj;
uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform vec4 lightPos;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

in vec4 inColor[1];

out vec4 color;
out vec4 objPos;
out vec4 camPos;
out vec4 light;
out float rad;
out float squareRad;

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewInv = inverse(modelview);

void main(void) {
    
    // remove the sphere radius from the w coordinates to the rad varyings
    //vec4 inPos = gl_in[0].gl_Position;
    vec4 inPos = gl_PositionIn[0];
    rad = inPos.w;
    squareRad = rad*rad;
    inPos.w = 1.0;

    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = modelviewInv[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    // USE THIS LINE TO GET POSITIONAL LIGHTING
    //lightPos = modelviewInv * gl_LightSource[0].position - objPos;
    // USE THIS LINE TO GET DIRECTIONAL LIGHTING
    light = modelviewInv*normalize(lightPos);
    
    // calculate light position in glyph space  
    color = inColor[0];    
    
       // Sphere-Touch-Plane-Approach
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

/*#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = gl_ModelViewMatrixInverse[3] + gl_ModelViewMatrixInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS*/

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    
#ifdef HALO
    squarRad = (rad + HALO_RAD) * (rad + HALO_RAD);
#endif // HALO
    
    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squareRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = modelviewproj * vec4(testPos, 1.0);
    projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    gl_Position = vec4(mins.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(mins.x, mins.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, maxs.y, 0.0, inPos.w); EmitVertex();
    gl_Position = vec4(maxs.x, mins.y, 0.0, inPos.w); EmitVertex();
    EndPrimitive();
}
-->
      </snippet>
    </shader>

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////




  <shader name="sphereFragmentGeom">
      <snippet type="version">140</snippet>
      <snippet name="commondefines"/>
      <snippet name="::common::lighting::simple"/>
      <snippet type="string">
        <!--
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_geometry_shader4 : enable

uniform vec4 viewAttr; // TODO: check fragment position if viewport starts not in (0, 0)
uniform mat4 modelview;
uniform mat4 proj;

in vec4 color;
in vec4 objPos;
in vec4 camPos;
in float rad;
in float squareRad;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
#endif // CALC_CAM_SYS

mat4 modelviewproj = proj*modelview; // TODO Move this to the CPU?
mat4 modelviewprojInv = inverse(modelviewproj);
mat4 modelviewprojTrans = transpose(modelviewproj);

void main(void) {
    vec4 coord;
    vec3 ray;
    float lambda;
    vec3 colOut;
    vec3 sphereintersection = vec3( 0.0);
    vec3 normal;

    // transform fragment coordinates from window coordinates to view coordinates.
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    
    // transform fragment coordinates from view coordinates to object coordinates.
    coord = modelviewprojInv * coord;
    coord /= coord.w;
    coord -= objPos; // ... and to glyph space
    
    // calc the viewing ray
    ray = normalize(coord.xyz - camPos.xyz);

    // calculate the geometry-ray-intersection
    float d1 = -dot(camPos.xyz, ray);                       // projected length of the cam-sphere-vector onto the ray
    float d2s = dot(camPos.xyz, camPos.xyz) - d1 * d1;      // off axis of cam-sphere-vector and ray
    float radicand = squareRad - d2s;                        // square of difference of projected length and lambda
#ifdef CLIP
    lambda = d1 - sqrt(radicand);                           // lambda

    float radicand2 = 0.0;
    if( radicand < 0.0 ) {
        discard;
    }
    else {
        // chose color for lighting
        colOut = color.rgb;
		if( lambda < 0.0 ) discard;
        sphereintersection = lambda * ray + camPos.xyz;    // intersection point
        // "calc" normal at intersection point
        normal = sphereintersection / rad;
    }
    
#endif // CLIP

	 gl_FragColor = vec4(color.x,color.y,color.z, 1.0);

    
    // calculate depth
#undef DEPTH
#ifdef DEPTH
    vec4 Ding = vec4(sphereintersection + objPos.xyz, 1.0);
    float depth = dot(modelviewprojTrans[2], Ding);
    float depthW = dot(modelviewprojTrans[3], Ding);
    gl_FragDepth = ((depth / depthW) + 1.0) * 0.5;
    
#ifndef CLIP
    gl_FragDepth = (radicand < 0.0) ? 1.0 : ((depth / depthW) + 1.0) * 0.5;
    gl_FragColor.rgb = (radicand < 0.0) ? color.rgb : gl_FragColor.rgb;
#endif // CLIP

#endif // DEPTH

    
#ifdef RETICLE
    coord = gl_FragCoord 
        * vec4(viewAttr.z, viewAttr.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);
    if (min(abs(coord.x - centerFragment.x), abs(coord.y - centerFragment.y)) < 0.002) {
        //gl_FragColor.rgb = vec3(1.0, 1.0, 0.5);
        gl_FragColor.rgb += vec3(0.3, 0.3, 0.5);
    }
#endif // RETICLE

//gl_FragColor.rgb = normal; // DEBUG
//gl_FragColor = color; // DEBUG
}
-->
      </snippet>
    </shader>





//******************************************************************
//**************** SHADER WITH TRANSFER FUNCTION *******************
//******************************************************************


<namespace name="withTransferFunction">

  <namespace name="triangleMesh">

  <shader name="vertex">
    <snippet type="version">120</snippet>
    <snippet type="string">
      <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

uniform mat4 modelView;
uniform mat4 projection;
uniform vec3 ligthSource;
uniform vec3 posOrigin;
uniform vec3 posExtents;
uniform vec3 aoSampDist;
uniform float aoSampFact;
uniform sampler3D aoVol;

uniform vec4 interactionColor;
uniform vec4 noInteractionColor;
uniform int curClusterID;

// control elements
uniform bool interactionForce;
uniform bool interactionForceAmountColoring;
uniform bool pocketArea;
uniform bool chemicalProperty;

// colors
uniform vec4 simpleColor;

// clipping plane
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform vec3 move;

uniform sampler1D tfTexture;
uniform vec2 tfRange;


varying vec3 normal, halfVector;
varying vec3 aoPos;
varying vec3 aoNeg;

varying vec4 posWS;
varying vec4 viewPos;

layout(shared, binding = 0) buffer meshVertices_ColorSwitch {
		int colorSwitch[];
	};

// clusterAssignment contains only true or false (0,1)    
layout(shared, binding = 1) buffer meshVertices_ClusterAssignment {
		int clusterAssignment[];
	};


void main(void) {  
    gl_Position = projection * modelView * gl_Vertex;
    normal = normalize(gl_Normal.xyz);

    viewPos = modelView * gl_Vertex; 

    if (any(notEqual(clipDat.xyz, vec3(0, 0, 0))) && 1 == 2) {
        float od = dot(gl_Vertex.xyz, clipDat.xyz) - clipDat.w;
        if(od < 0 ){
       
            //gl_FragColor = clipCol;
            float dist = dot(clipDat.xyz, (gl_Vertex.xyz-move))- clipDat.w;
            vec3 newD = gl_Vertex.xyz - (dist * normalize(clipDat.xyz));
            gl_Position = projection * modelView *vec4(newD.xyz,1.0);
            //posWS = vec4(newD.xyz,1.0);
        }
           
    }


    posWS = gl_Vertex;

   // default coloring 
    if(chemicalProperty){
        gl_FrontColor = vec4(vec3(gl_Color),interactionColor.w);
        gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5,interactionColor.w);
    }else{
        gl_FrontColor = noInteractionColor;
        gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5,noInteractionColor.w);
    }
   

    // pocket area 
    if(pocketArea){
        if(clusterAssignment[gl_VertexID] != 0){
             if(chemicalProperty){
                gl_FrontColor = vec4(vec3(gl_Color),interactionColor.w);
                gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5,interactionColor.w);
             }else{
                    gl_FrontColor = vec4(vec3(0.6,0.6,0.6),interactionColor.w);
                    gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5,interactionColor.w);  
             }
            
        }else{
             gl_FrontColor = noInteractionColor;
             gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5, noInteractionColor.w);
        }
    }

    // interaction force
    if(interactionForce){ 
        // colors only to a pocket assigned interaction forces 
        if(clusterAssignment[gl_VertexID] != 0 && colorSwitch[gl_VertexID] != 0){
            if(!interactionForceAmountColoring){
                gl_FrontColor = vec4(vec3(simpleColor),interactionColor.w);
            }else{
                float tmp = (float(colorSwitch[gl_VertexID]) - tfRange.x) / tfRange.y;
                gl_FrontColor = vec4(vec3(texture1D(tfTexture, tmp)),interactionColor.w);
            }
            
            gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5, interactionColor.w);
        }
        // colors all interaction forces (overview when nothing is selected) 
        else if(curClusterID == 0 && colorSwitch[gl_VertexID] != 0){
             if(!interactionForceAmountColoring){
                gl_FrontColor = vec4(vec3(simpleColor),interactionColor.w);
            }else{
                float tmp = (float(colorSwitch[gl_VertexID]) - tfRange.x) / tfRange.y;
                gl_FrontColor = vec4(vec3(texture1D(tfTexture, tmp)),interactionColor.w);
            }
            gl_BackColor =  vec4(vec3(0.6,0.6,0.6)*2.5, interactionColor.w);
        }
    }
    

    
   
    // normalize the halfVector to pass it to the fragment shader
    halfVector = normalize(ligthSource.xyz-gl_Vertex.xyz);    

    vec3 aop = (gl_Vertex.xyz - posOrigin) / posExtents;
    vec4 aod = vec4(aoSampDist / posExtents, 0.0);
    // vec4 aod = vec4((vec3(rad) + aoSampDist) / posExtents, 0.0);
    //vec4 aod = vec4(0.0);
    aoPos.x = 1.0 - (texture3D(aoVol, aop + aod.xww).r * aoSampFact);
    aoPos.y = 1.0 - (texture3D(aoVol, aop + aod.wyw).r * aoSampFact);
    aoPos.z = 1.0 - (texture3D(aoVol, aop + aod.wwz).r * aoSampFact);
    aoNeg.x = 1.0 - (texture3D(aoVol, aop - aod.xww).r * aoSampFact);
    aoNeg.y = 1.0 - (texture3D(aoVol, aop - aod.wyw).r * aoSampFact);
    aoNeg.z = 1.0 - (texture3D(aoVol, aop - aod.wwz).r * aoSampFact);
}
-->
    </snippet>
  </shader>



  <shader name="fragment">
    <snippet type="version">120</snippet>
    <snippet type="string">
      <!--
uniform mat4 MVinv;
uniform mat4 modelView;
uniform mat4 projection;
uniform vec3 ligthSource;
uniform float aoIntensityMin;
uniform float aoIntensityMax;

// clipping plane
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform vec3 move;

varying vec3 normal, halfVector;
varying vec3 aoPos;
varying vec3 aoNeg;

varying vec4 posWS;
varying vec4 viewPos;

   

void main(void) {
    
    vec3 lightDir =  normalize(ligthSource);
    vec4 lightparams = vec4(0.5, 0.5, 0.2, 5.0);
    #define LIGHT_AMBIENT lightparams.x
    #define LIGHT_DIFFUSE lightparams.y
    #define LIGHT_SPECULAR lightparams.z
    #define LIGHT_EXPONENT lightparams.w    
    float NdotL, NdotHV;
    vec3 n,halfV;
    vec3 color = LIGHT_AMBIENT * gl_Color.xyz;

   
    
    
    // store the normalized interpolated normal
    n = normalize(normal);

    // compute the dot product between normal and lightDir
    NdotL = max(dot(n,lightDir.xyz),0.0);
    float transparencyFactor = 1.0-abs(dot(n,-lightDir.xyz));
   
    if (NdotL > 0.0) {
        color += gl_Color.xyz * LIGHT_DIFFUSE * NdotL;
        //halfV = normalize(MVinv * vec4(halfVector, 0.0)).xyz;
         NdotHV = max(dot(n,halfVector),0.0);
        color += LIGHT_SPECULAR * vec3(pow(NdotHV, LIGHT_EXPONENT));
    }
   
    // if (length(halfVector) < 20.0){
    //     color += LIGHT_DIFFUSE * gl_Color.xyz;  
    // }
     vec3 aoFac = vec3(
      (n.x > 0.0) ? aoPos.x : aoNeg.x,
      (n.y > 0.0) ? aoPos.y : aoNeg.y,
      (n.z > 0.0) ? aoPos.z : aoNeg.z);
    aoFac.x *= (n.x * n.x);
    aoFac.y *= (n.y * n.y);
    aoFac.z *= (n.z * n.z);
    float aoFactor = aoFac.x + aoFac.y + aoFac.z;
    aoFactor = mix(aoIntensityMin, aoIntensityMax, aoFactor);
   
    if ( gl_Color.w < 0.8){
         gl_FragColor = vec4(color*aoFactor,gl_Color.w*transparencyFactor);
           
    }else{
        gl_FragColor = vec4(color* aoFactor,gl_Color.w);
    }

     // Clipping
    if (any(notEqual(clipDat.xyz, vec3(0, 0, 0)))) {
        //float www = dot(clipDat.xyz,move.xyz);
        vec3 posWStmp = posWS.xyz / posWS.w;

        float od = dot(posWStmp.xyz, normalize(clipDat.xyz))- clipDat.w+0.0001;
        if(od < 0){
           discard;    
        }
    }
  

}
-->
    </snippet>
  </shader>
</namespace> // triangleMesh


</namespace> //withTransferFunction
</namespace> // docking

</btf>
